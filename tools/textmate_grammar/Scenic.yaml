---
# TextMate grammar for the Scenic scenario description language,
# by Daniel Fremont.
# https://scenic-lang.readthedocs.io/
#
# This grammar is based on the MagicPython grammar by MagicStack Inc.,
# available at https://github.com/MagicStack/MagicPython.
#
# This file is a modified version of MagicPython.syntax.yaml; all other .yaml
# files in this directory are copied from MagicPython without changes. The
# original files are distributed under the MIT License: see the LICENSE file.
name: Scenic
scopeName: source.scenic
fileTypes: [scenic]
uuid: D2D1386D-B1E9-4A1B-9A90-C4132CC17E40

patterns:
  - include: '#statement'
  - include: '#expression'

repository:
  $apply:
    - file: 'regexp-common.inc.syntax.yaml'

    - file: 'comment.inc.syntax.yaml'
      vars:
        suffix: '-base'
        marker: ""

    - file: 'comment.inc.syntax.yaml'
      vars:
        suffix: '-string-single-three'
        marker: "|(?=''')"

    - file: 'comment.inc.syntax.yaml'
      vars:
        suffix: '-string-double-three'
        marker: '|(?=""")'

    - file: 'regexp.inc.syntax.yaml'
      vars:
        prefix: 'single-one-'
        basename: 'regexp'
        marker: "|(?=\\')"
        nested: ''
        guard: "|((?=(?<!\\\\)\\n))"

    - file: 'regexp.inc.syntax.yaml'
      vars:
        prefix: 'single-three-'
        basename: 'regexp'
        marker: "|(?=\\'\\'\\')"
        nested: "- include: '#comments-string-single-three'"
        guard: ""

    - file: 'regexp.inc.syntax.yaml'
      vars:
        prefix: 'double-one-'
        basename: 'regexp'
        marker: '|(?=")'
        nested: ''
        guard: "|((?=(?<!\\\\)\\n))"

    - file: 'regexp.inc.syntax.yaml'
      vars:
        prefix: 'double-three-'
        basename: 'regexp'
        marker: '|(?=""")'
        nested: "- include: '#comments-string-double-three'"
        guard: ""

    - file: 'regexp.wrapper.syntax.yaml'
      vars:
        scopename: string.regexp.quoted.single.python
        prefix: 'single-one-'
        basename: 'regexp'
        nested: ''
        modifier: '[bB]'
        bquote: "(\\')"
        equote: "(\\')|(?<!\\\\)(\\n)"

    - file: 'regexp.wrapper.syntax.yaml'
      vars:
        scopename: string.regexp.quoted.multi.python
        prefix: 'single-three-'
        basename: 'regexp'
        nested: "- include: '#comments-string-single-three'"
        modifier: '[bB]'
        bquote: "(\\'\\'\\')"
        equote: "(\\'\\'\\')"

    - file: 'regexp.wrapper.syntax.yaml'
      vars:
        scopename: string.regexp.quoted.single.python
        prefix: 'double-one-'
        basename: 'regexp'
        nested: ''
        modifier: '[bB]'
        bquote: '(")'
        equote: '(")|(?<!\\)(\n)'

    - file: 'regexp.wrapper.syntax.yaml'
      vars:
        scopename: string.regexp.quoted.multi.python
        prefix: 'double-three-'
        basename: 'regexp'
        nested: "- include: '#comments-string-double-three'"
        modifier: '[bB]'
        bquote: '(""")'
        equote: '(""")'

    - file: 'regexp.inc.syntax.yaml'
      vars:
        prefix: 'single-one-'
        basename: 'fregexp'
        marker: "|(?=\\')"
        nested: ''
        guard: "|((?=(?<!\\\\)\\n))"

    - file: 'regexp.inc.syntax.yaml'
      vars:
        prefix: 'single-three-'
        basename: 'fregexp'
        marker: "|(?=\\'\\'\\')"
        nested: "- include: '#comments-string-single-three'"
        guard: ""

    - file: 'regexp.inc.syntax.yaml'
      vars:
        prefix: 'double-one-'
        basename: 'fregexp'
        marker: '|(?=")'
        nested: ''
        guard: "|((?=(?<!\\\\)\\n))"

    - file: 'regexp.inc.syntax.yaml'
      vars:
        prefix: 'double-three-'
        basename: 'fregexp'
        marker: '|(?=""")'
        nested: "- include: '#comments-string-double-three'"
        guard: ""

    - file: 'regexp.wrapper.syntax.yaml'
      vars:
        scopename: string.regexp.quoted.single.python
                   string.interpolated.python
        prefix: 'single-one-'
        basename: 'fregexp'
        nested: ''
        modifier: '[fF]'
        bquote: "(\\')"
        equote: "(\\')|(?<!\\\\)(\\n)"

    - file: 'regexp.wrapper.syntax.yaml'
      vars:
        scopename: string.regexp.quoted.multi.python
                   string.interpolated.python
        prefix: 'single-three-'
        basename: 'fregexp'
        nested: "- include: '#comments-string-single-three'"
        modifier: '[fF]'
        bquote: "(\\'\\'\\')"
        equote: "(\\'\\'\\')"

    - file: 'regexp.wrapper.syntax.yaml'
      vars:
        scopename: string.regexp.quoted.single.python
                   string.interpolated.python
        prefix: 'double-one-'
        basename: 'fregexp'
        nested: ''
        modifier: '[fF]'
        bquote: '(")'
        equote: '(")|(?<!\\)(\n)'

    - file: 'regexp.wrapper.syntax.yaml'
      vars:
        scopename: string.regexp.quoted.multi.python
                   string.interpolated.python
        prefix: 'double-three-'
        basename: 'fregexp'
        nested: "- include: '#comments-string-double-three'"
        modifier: '[fF]'
        bquote: '(""")'
        equote: '(""")'

    - file: 'pystring.inc.syntax.yaml'
      vars:
        line: single
        marker: (['"])
        guard: "|((?<!\\\\)\\n)"

    - file: 'pystring.inc.syntax.yaml'
      vars:
        line: multi
        marker: "'''|\"\"\""
        guard: ""

    - file: 'pyfstring.inc.syntax.yaml'
      vars:
        line: single
        marker: (['"])
        fguard: "|(?=\\n)"
        guard: "|((?<!\\\\)\\n)"

    - file: 'pyfstring.inc.syntax.yaml'
      vars:
        line: multi
        marker: "'''|\"\"\""
        fguard: ""
        guard: ""


  impossible:
    comment: This is a special rule that should be used where no match
             is desired. It is not a good idea to match something like
             '1{0}' because in some cases that can result in infinite
             loops in token generation. So the rule instead matches
             and impossible expression to allow a match to fail and
             move to the next token.
    match: '$.^'

  statement:
    patterns:
      - include: '#import'
      - include: '#class-declaration'
      - include: '#function-declaration'
      - include: '#scenario-declaration'
      - include: '#monitor-declaration'
      - include: '#statement-keyword'
      - include: '#param-statement'
      - include: '#statement-keyword-scenic'
      - include: '#assignment-operator'
      - include: '#decorator'
      - include: '#property-declaration'
      - include: '#docstring-statement'
      - include: '#semicolon'
      - include: '#instance-statement'

  statement-keyword-scenic:
    patterns:
      - comment: These statements match only at the start of a line.
        name: keyword.control.flow.scenic
        match: |
          (?x)
            ^\s*(
              model | simulator | param
              | require\ always | require\ eventually | require
              | terminate\ when | terminate\ after
              | mutate
              | record\ initial | record\ final | record
              | take | wait | terminate
              | do\ choose | do\ shuffle | do
              | abort | override
              | try | interrupt\ when
            )\b
      - comment: These modifiers match only at the end of a line (excluding comments).
        name: keyword.control.flow.scenic
        match: |
          (?x)
            \b(?<!\.)(seconds | steps)\b (?= \s*(\#.*)? $)
      - comment: These keywords occur mid-line and have to be matched everywhere.
        name: keyword.control.flow.scenic
        match: |
          (?x)
            \b(?<!\.)(
              initial\ scenario | until
            )\b
      - name: keyword.control.flow.scenic
        match: |
          (?x)
            ^\s*(setup | compose | precondition | invariant)(:)
        captures:
          '1': {name: keyword.control.flow.scenic}
          '2': {name: punctuation.section.function.begin.python}

  param-statement:
    comment: Extra rule to prevent param names from being colored if they happen
             to agree with a built-in name
    patterns:
      - match: |
          (?x)
            ^\s*(param) \s* [[:alpha:]_]\w* \s* (=)
        captures:
          '1': {name: keyword.control.flow.scenic}
          '2': {name: keyword.operator.assignment.scenic}

  property-declaration:
    patterns:
      - match: |
          (?x)
            ^\s+
            (?!else)
            ([[:alpha:]_]\w*)(:)\s+
        captures:
          '1': {name: entity.name.property.scenic}
          '2': {name: punctuation.separator.colon.scenic}

  semicolon:
    patterns:
      - name: invalid.deprecated.semicolon.python
        match: '\;$'

  comments:
    patterns:
      - name: comment.line.number-sign.python
        contentName: meta.typehint.comment.python

        begin: |
          (?x)
            (?:
              \# \s* (type:)
              \s*+ (?# we want `\s*+` which is possessive quantifier since
                       we do not actually want to backtrack when matching
                       whitespace here)
              (?! $ | \#)
            )

        end: (?:$|(?=\#))
        beginCaptures:
          '0': {name: meta.typehint.comment.python}
          '1': {name: comment.typehint.directive.notation.python}

        patterns:
          - name: comment.typehint.ignore.notation.python
            match: |
              (?x)
                \G ignore
                (?= \s* (?: $ | \#))

          - name: comment.typehint.type.notation.python
            match: |
              (?x)
                (?<!\.)\b(
                  bool | bytes | float | int | object | str
                  | List | Dict | Iterable | Sequence | Set
                  | FrozenSet | Callable | Union | Tuple
                  | Any | None
                )\b

          - name: comment.typehint.punctuation.notation.python
            match: ([\[\]\(\),\.\=\*]|(->))

          - name: comment.typehint.variable.notation.python
            match: ([[:alpha:]_]\w*)

      - include: '#comments-base'

  docstring-statement:
    begin: ^(?=\s*[rR]?(\'\'\'|\"\"\"|\'|\"))
    comment: the string either terminates correctly or by the
             beginning of a new line (this is for single line
             docstrings that aren't terminated) AND it's not followed
             by another docstring
    end: ((?<=\1)|^)(?!\s*[rR]?(\'\'\'|\"\"\"|\'|\"))
    patterns:
      - include: '#docstring'

  docstring:
    patterns:
      - name: string.quoted.docstring.multi.python
        begin: (\'\'\'|\"\"\")
        end: (\1)
        beginCaptures:
          '1': {name: punctuation.definition.string.begin.python}
        endCaptures:
          '1': {name: punctuation.definition.string.end.python}
        patterns:
          - include: '#docstring-prompt'
          - include: '#codetags'
          - include: '#docstring-guts-unicode'

      - name: string.quoted.docstring.raw.multi.python
        begin: ([rR])(\'\'\'|\"\"\")
        end: (\2)
        beginCaptures:
          '1': {name: storage.type.string.python}
          '2': {name: punctuation.definition.string.begin.python}
        endCaptures:
          '1': {name: punctuation.definition.string.end.python}
        patterns:
          - include: '#string-consume-escape'
          - include: '#docstring-prompt'
          - include: '#codetags'

      - name: string.quoted.docstring.single.python
        begin: (\'|\")
        end: (\1)|(\n)
        beginCaptures:
          '1': {name: punctuation.definition.string.begin.python}
        endCaptures:
          '1': {name: punctuation.definition.string.end.python}
          '2': {name: invalid.illegal.newline.python}
        patterns:
          - include: '#codetags'
          - include: '#docstring-guts-unicode'

      - name: string.quoted.docstring.raw.single.python
        begin: ([rR])(\'|\")
        end: (\2)|(\n)
        beginCaptures:
          '1': {name: storage.type.string.python}
          '2': {name: punctuation.definition.string.begin.python}
        endCaptures:
          '1': {name: punctuation.definition.string.end.python}
          '2': {name: invalid.illegal.newline.python}
        patterns:
          - include: '#string-consume-escape'
          - include: '#codetags'

  docstring-guts-unicode:
    patterns:
      - include: '#escape-sequence-unicode'
      - include: '#escape-sequence'
      - include: '#string-line-continuation'

  docstring-prompt:
    match: |
      (?x)
        (?:
          (?:^|\G) \s* (?# '\G' is necessary for ST)
          ((?:>>>|\.\.\.) \s) (?=\s*\S)
        )
    captures:
      '1': {name: keyword.control.flow.python}

  statement-keyword:
    patterns:
      - name: storage.type.function.python
        match: \b((async\s+)?\s*def)\b
      - name: keyword.control.flow.python
        match: |
          (?x)
            \b(?<!\.)(
              as | async | continue | del | assert | break | finally | for
              | from | elif | else | if | except | pass | raise
              | return | try | while | with
            )\b
      - name: storage.modifier.declaration.python
        match: |
          (?x)
            \b(?<!\.)(
              global | nonlocal
            )\b
      - name: storage.type.class.python
        match: \b(?<!\.)(class)\b

  expression-bare:
    comment: valid Python expressions w/o comments and line continuation
    patterns:
      - include: '#backticks'
      - include: '#illegal-anno'
      - include: '#literal'
      - include: '#regexp'
      - include: '#string'
      - include: '#lambda'
      - include: '#illegal-operator'
      - include: '#operator'
      - include: '#curly-braces'
      - include: '#item-access'
      - include: '#list'
      - include: '#round-braces'
      - include: '#function-call'
      - include: '#builtin-functions'
      - include: '#builtin-types'
      - include: '#builtin-types-scenic'
      - include: '#builtin-exceptions'
      - include: '#magic-names'
      - include: '#special-names'
      - include: '#builtin-names-scenic'
      - include: '#illegal-names'
      - include: '#special-variables'
      - include: '#ellipsis'
      - include: '#punctuation'
      - include: '#line-continuation'

  expression-base:
    comment: valid Python expressions with comments and line continuation
    patterns:
      - include: '#comments'
      - include: '#expression-bare'
      - include: '#line-continuation'

  expression:
    comment: All valid Python expressions
    patterns:
      - include: '#expression-base'
      - include: '#member-access'
      - comment: Tokenize identifiers to help linters
        match: (?x) \b ([[:alpha:]_]\w*) \b

  member-access:
    begin: (\.)\s*(?!\.)
    end: |
      (?x)
        # stop when you've just read non-whitespace followed by non-word
        # i.e. when finished reading an identifier or function call
        (?<=\S)(?=\W) |
        # stop when seeing the start of something that's not a word,
        # i.e. when seeing a non-identifier
        (^|(?<=\s))(?=[^\\\w\s]) |
        $
    beginCaptures:
      '1': {name: punctuation.separator.period.python}
    patterns:
      - include: '#function-call'
      - include: '#member-access-base'

  member-access-base:
    patterns:
      - include: '#magic-names'
      - include: '#illegal-names'
      - include: '#illegal-object-name'
      - include: '#special-names'
      - include: '#line-continuation'
      - include: '#item-access'

  special-names:
    name: constant.other.caps.python
    match: |
      (?x)
        \b
          # we want to see "enough", meaning 2 or more upper-case
          # letters in the beginning of the constant
          #
          # for more details refer to:
          #   https://github.com/MagicStack/MagicPython/issues/42
          (
            _* [[:upper:]] [_\d]* [[:upper:]]
          )
          [[:upper:]\d]* (_\w*)?
        \b

  curly-braces:
    begin: \{
    end: \}
    beginCaptures:
      '0': {name: punctuation.definition.dict.begin.python}
    endCaptures:
      '0': {name: punctuation.definition.dict.end.python}
    patterns:
      - name: punctuation.separator.dict.python
        match: ":"
      - include: '#expression'

  list:
    begin: \[
    end: \]
    beginCaptures:
      '0': {name: punctuation.definition.list.begin.python}
    endCaptures:
      '0': {name: punctuation.definition.list.end.python}
    patterns:
      - include: '#expression'

  round-braces:
    begin: \(
    end: \)
    beginCaptures:
      '0': {name: punctuation.parenthesis.begin.python}
    endCaptures:
      '0': {name: punctuation.parenthesis.end.python}
    patterns:
      - include: '#expression'

  line-continuation:
    patterns:
      - match: '(\\)\s*(\S.*$\n?)'
        captures:
          '1': {name: punctuation.separator.continuation.line.python}
          '2': {name: invalid.illegal.line.continuation.python}
      - begin: '(\\)\s*$\n?'
        # Line continuation matching ends on anything that is not a
        # potential docstring. For docstring-like strings we explicitly
        # match regexp and string.
        end: |
          (?x)
            (?=^\s*$)
            |
            (?! (\s* [rR]? (\'\'\'|\"\"\"|\'|\"))
                |
                (\G $)  (?# '\G' is necessary for ST)
            )
        beginCaptures:
          '1': {name: punctuation.separator.continuation.line.python}
        patterns:
          - include: '#regexp'
          - include: '#string'

  assignment-operator:
    name: keyword.operator.assignment.python
    match: |
      (?x)
           <<= | >>= | //= | \*\*=
          | \+= | -= | /= | @=
          | \*= | %= | ~= | \^= | &= | \|=
          | =(?!=)

  instance-statement:
    name: meta.instance.scenic
    begin: |
      (?x)
        ^\s*
        (?: (?: (ego) | [[:alpha:]_]\w* ) \s* (=) | (return))? \s*
        (?! True|False|None|NotImplemented|Ellipsis) ([[:upper:]]\w*)
        (?=
          \s* (\#.*)? $
          | \s+ (
            (with) \s+ \b[[:alpha:]_]\w*
            | (
              at | offset\ by | offset\ along
              | ((left | right | ahead)\ of) | behind
              | beyond
              | visible\ from | visible
              | not\ visible\ from | not\ visible
              | in | on
              | following
              | facing\ (toward | away\ from) | facing
              | apparently\ facing
            )
          )
        )\b
    end: \n
    beginCaptures:
      '1': {name: variable.language.special.ego.scenic}
      '2': {name: keyword.operator.assignment.python}
      '3': {name: keyword.control.flow.python}
      '4': {name: entity.name.instance.scenic markup.bold}
    patterns:
      - include: '#specifier'
      - include: '#line-continuation'

  specifier:
    name: meta.specifier.scenic
    begin: |
      (?x)
        \b(?<!\.) (?:
          (with) \s+ \b[[:alpha:]_]\w*
          | (
            at | offset\ by | offset\ along
            | ((left | right | ahead)\ of) | behind
            | beyond
            | visible\ from | visible
            | not\ visible\ from | not\ visible
            | in | on
            | following
            | facing\ (toward | away\ from) | facing
            | apparently\ facing
          )
        )\b
    end: |
      (?x)
        (,) \s* (?: (\#.*)? \n)?
        | (?=\n)
    beginCaptures:
      '1': {name: keyword.other.specifier.scenic}
      '2': {name: keyword.other.specifier.scenic}
    endCaptures:
      '1': {name: punctuation.separator.specifier.scenic}
      '2': {name: comment.line.number-sign.python}
    patterns:
      - comment: Special case to eagerly match line continuations, avoiding a
                 corner of the Python grammar meant to catch docstrings.
        match: '(\\)\s*\n'
        captures:
          '1': {name: punctuation.separator.continuation.line.python}
      - include: '#expression'

  operator:
    match: |
      (?x)
          \b(?<!\.)
            (?:
              (and | or | not | in | is)                         (?# 1)
              |
              (for | if | else | await | (?:yield(?:\s+from)?))  (?# 2)
            )
          (?!\s*:)\b

          | (<< | >> | & | \| | \^ | ~)                          (?# 3)

          | (\*\* | \* | \+ | - | % | // | / | @)                (?# 4)

          | (!= | == | >= | <= | < | >)                          (?# 5)

          | (                                                    (?# 6)
            deg
            | (?:
                (?:relative | apparent)\ heading\ of
                | distance\ (?:from | to) | distance
                | angle\ from | angle | can\ see
                | at | relative\ to
                | offset\ by | offset\ along
                | visible | not\ visible
                | (?:front | back | left | right)\ of
                | (?:(?:front | back)\ (?:left | right))\ of
                | to | by
              )\b(?!\s*[)}\]])
            )

    captures:
      '1': {name: keyword.operator.logical.python}
      '2': {name: keyword.control.flow.python}
      '3': {name: keyword.operator.bitwise.python}
      '4': {name: keyword.operator.arithmetic.python}
      '5': {name: keyword.operator.comparison.python}
      '6': {name: keyword.operator.scenic}

  punctuation:
    patterns:
      - name: punctuation.separator.colon.python
        match: ":"
      - name: punctuation.separator.element.python
        match: ","

  literal:
    patterns:
      - name: constant.language.python
        match: \b(True|False|None|NotImplemented|Ellipsis)\b
      - name: constant.language.scenic
        match: \b(everywhere|nowhere)\b

      - include: '#number'

  number:
    name: constant.numeric.python
    patterns:
      - include: '#number-float'
      - include: '#number-dec'
      - include: '#number-hex'
      - include: '#number-oct'
      - include: '#number-bin'
      - include: '#number-long'
      - name: invalid.illegal.name.python
        match: \b[0-9]+\w+

  number-float:
    name: constant.numeric.float.python
    match: |
      (?x)
        (?<! \w)(?:
          (?:
            \.[0-9](?: _?[0-9] )*
            |
            [0-9](?: _?[0-9] )* \. [0-9](?: _?[0-9] )*
            |
            [0-9](?: _?[0-9] )* \.
          ) (?: [eE][+-]?[0-9](?: _?[0-9] )* )?
          |
          [0-9](?: _?[0-9] )* (?: [eE][+-]?[0-9](?: _?[0-9] )* )
        )([jJ])?\b
    captures:
      '1': {name: storage.type.imaginary.number.python}

  number-dec:
    name: constant.numeric.dec.python
    match: |
      (?x)
        (?<![\w\.])(?:
            [1-9](?: _?[0-9] )*
            |
            0+
            |
            [0-9](?: _?[0-9] )* ([jJ])
            |
            0 ([0-9]+)(?![eE\.])
        )\b
    captures:
      '1': {name: storage.type.imaginary.number.python}
      '2': {name: invalid.illegal.dec.python}
      '3': {name: invalid.illegal.dec.python}

  number-hex:
    name: constant.numeric.hex.python
    match: |
      (?x)
        (?<![\w\.])
          (0[xX]) (_?[0-9a-fA-F])+
        \b
    captures:
      '1': {name: storage.type.number.python}

  number-oct:
    name: constant.numeric.oct.python
    match: |
      (?x)
        (?<![\w\.])
          (0[oO]) (_?[0-7])+
        \b
    captures:
      '1': {name: storage.type.number.python}

  number-bin:
    name: constant.numeric.bin.python
    match: |
      (?x)
        (?<![\w\.])
          (0[bB]) (_?[01])+
        \b
    captures:
      '1': {name: storage.type.number.python}

  number-long:
    name: constant.numeric.bin.python
    comment: this is to support python2 syntax for long ints
    match: |
      (?x)
        (?<![\w\.])
          ([1-9][0-9]* | 0) ([lL])
        \b
    captures:
      '2': {name: storage.type.number.python}

  regexp:
    patterns:
      - include: '#regexp-single-three-line'
      - include: '#regexp-double-three-line'
      - include: '#regexp-single-one-line'
      - include: '#regexp-double-one-line'
      - include: '#fregexp-single-three-line'
      - include: '#fregexp-double-three-line'
      - include: '#fregexp-single-one-line'
      - include: '#fregexp-double-one-line'

  string:
    patterns:
      - include: '#string-quoted-multi-line'
      - include: '#string-quoted-single-line'
      - include: '#string-bin-quoted-multi-line'
      - include: '#string-bin-quoted-single-line'
      - include: '#string-raw-quoted-multi-line'
      - include: '#string-raw-quoted-single-line'
      - include: '#string-raw-bin-quoted-multi-line'
      - include: '#string-raw-bin-quoted-single-line'
      - include: '#fstring-fnorm-quoted-multi-line'
      - include: '#fstring-fnorm-quoted-single-line'
      - include: '#fstring-normf-quoted-multi-line'
      - include: '#fstring-normf-quoted-single-line'
      - include: '#fstring-raw-quoted-multi-line'
      - include: '#fstring-raw-quoted-single-line'

  string-unicode-guts:
    patterns:
      - include: '#escape-sequence-unicode'
      - include: '#string-entity'
      - include: '#string-brace-formatting'

  string-consume-escape:
    match: \\['"\n\\]

  string-raw-guts:
    patterns:
      - include: '#string-consume-escape'
      - include: '#string-formatting'
      - include: '#string-brace-formatting'

  string-raw-bin-guts:
    patterns:
      - include: '#string-consume-escape'
      - include: '#string-formatting'

  string-entity:
    patterns:
      - include: '#escape-sequence'
      - include: '#string-line-continuation'
      - include: '#string-formatting'

  fstring-guts:
    patterns:
      - include: '#escape-sequence-unicode'
      - include: '#escape-sequence'
      - include: '#string-line-continuation'
      - include: '#fstring-formatting'

  fstring-raw-guts:
    patterns:
      - include: '#string-consume-escape'
      - include: '#fstring-formatting'

  fstring-illegal-single-brace:
    comment: it is illegal to have a multiline brace inside a single-line
             string
    begin: (\{)(?=[^\n}]*$\n?)
    end: (\})|(?=\n)
    beginCaptures:
      '1': {name: constant.character.format.placeholder.other.python}
    endCaptures:
      '1': {name: constant.character.format.placeholder.other.python}
    patterns:
      - include: '#fstring-terminator-single'
      - include: '#f-expression'

  fstring-illegal-multi-brace:
    patterns:
      - include: '#impossible'

  f-expression:
    comment: All valid Python expressions, except comments and line cont
    patterns:
      - include: '#expression-bare'
      - include: '#member-access'
      - comment: Tokenize identifiers to help linters
        match: (?x) \b ([[:alpha:]_]\w*) \b

  escape-sequence-unicode:
    patterns:
      - name: constant.character.escape.python
        match: |
          (?x)
            \\ (
                  u[0-9A-Fa-f]{4}
                  | U[0-9A-Fa-f]{8}
                  | N\{[\w\s]+?\}
               )

  escape-sequence:
    name: constant.character.escape.python
    match: |
      (?x)
        \\ (
              x[0-9A-Fa-f]{2}
              | [0-7]{1,3}
              | [\\"'abfnrtv]
           )

  string-line-continuation:
    name: constant.language.python
    match: \\$

  string-formatting:
    name: meta.format.percent.python
    match: |
      (?x)
        (
          % (\([\w\s]*\))?
            [-+#0 ]*
            (\d+|\*)? (\.(\d+|\*))?
            ([hlL])?
            [diouxXeEfFgGcrsab%]
        )
    captures:
      '1': {name: constant.character.format.placeholder.other.python}

  string-brace-formatting:
    patterns:
      - name: meta.format.brace.python
        match: |
          (?x)
            (
              {{ | }}
              | (?:
                {
                  \w* (\.[[:alpha:]_]\w* | \[[^\]'"]+\])*
                  (![rsa])?
                  ( : \w? [<>=^]? [-+ ]? \#?
                    \d* ,? (\.\d+)? [bcdeEfFgGnosxX%]? )?
                })
            )
        captures:
          # We use this awkward scope name instead of perhaps more
          # elegant "support.other.format.python" because it appears
          # that by default it gives a better visual result in various
          # systems (e.g. GitHub). This is due to the fact that
          # "storage.type..." is more likely to have special
          # highlighting in any given color scheme than
          # "support.other..."
          '1': {name: constant.character.format.placeholder.other.python}
          '3': {name: storage.type.format.python}
          '4': {name: storage.type.format.python}

      # The reason for 2 separate rules is to establish which one
      # should be matched with a higher priority. The rule below is
      # more generic, so it should be matched only if the specific one
      # didn't.
      - name: meta.format.brace.python
        match: |
          (?x)
            (
              {
                \w* (\.[[:alpha:]_]\w* | \[[^\]'"]+\])*
                (![rsa])?
                (:)
                  [^'"{}\n]* (?:
                    \{ [^'"}\n]*? \} [^'"{}\n]*
                  )*
              }
            )
        captures:
          '1': {name: constant.character.format.placeholder.other.python}
          '3': {name: storage.type.format.python}
          '4': {name: storage.type.format.python}

  fstring-formatting:
    patterns:
      - include: '#fstring-formatting-braces'
      - include: '#fstring-formatting-singe-brace'

  fstring-formatting-singe-brace:
    name: invalid.illegal.brace.python
    match: (}(?!}))

  import:
    comment: |
      Import statements
    patterns:
      - match: |
          (?x)
            \s* \b(from) \s*(\.+)\s* (import\b)?
        captures:
          '1': {name: keyword.control.import.python}
          '2': {name: punctuation.separator.period.python}
          '3': {name: keyword.control.import.python}
      - name: keyword.control.import.python
        match: \b(?<!\.)import\b

  class-declaration:
    patterns:
      - name: meta.class.python
        begin: |
          (?x)
            \s*(class)\s+
              (?=
                [[:alpha:]_]\w* \s* (:|\()
              )
        end: (:)
        beginCaptures:
          '1': {name: storage.type.class.python}
        endCaptures:
          '1': {name: punctuation.section.class.begin.python}
        patterns:
          - include: '#class-name'
          - include: '#class-inheritance'

  class-name:
    patterns:
      - include: '#illegal-object-name'
      - include: '#builtin-possible-callables'
      - name: entity.name.type.class.python
        match: |
          (?x)
            \b ([[:alpha:]_]\w*) \b

  class-inheritance:
    name: meta.class.inheritance.python
    begin: (\()
    end: (\))
    beginCaptures:
      '1': {name: punctuation.definition.inheritance.begin.python}
    endCaptures:
      '1': {name: punctuation.definition.inheritance.end.python}
    patterns:
      - name: keyword.operator.unpacking.arguments.python
        match: (\*\*|\*)
      - name: punctuation.separator.inheritance.python
        match: ','
      - name: keyword.operator.assignment.python
        match: =(?!=)
      - name: support.type.metaclass.python
        match: \bmetaclass\b
      - include: '#illegal-names'
      - include: '#class-kwarg'
      - include: '#call-wrapper-inheritance'
      - include: '#expression-base'
      - include: '#member-access-class'
      - include: '#inheritance-identifier'

  class-kwarg:
    match: |
      (?x)
        \b ([[:alpha:]_]\w*) \s*(=)(?!=)
    captures:
      # "variable.parameter.class.python" scope is more important
      # and hence we specify it first to highlight class parameters
      # as kwargs in Atom/VSCode/GH.
      '1': {name: variable.parameter.class.python
                  entity.other.inherited-class.python}
      '2': {name: keyword.operator.assignment.python}

  inheritance-identifier:
    match: |
      (?x)
        \b ([[:alpha:]_]\w*) \b
    captures:
      '1': {name: entity.other.inherited-class.python}

  member-access-class:
    begin: (\.)\s*(?!\.)
    end: (?<=\S)(?=\W)|$
    beginCaptures:
      '1': {name: punctuation.separator.period.python}
    patterns:
      - include: '#call-wrapper-inheritance'
      - include: '#member-access-base'
      - include: '#inheritance-identifier'

  lambda:
    patterns:
      - match: ((?<=\.)lambda|lambda(?=\s*[\.=]))
        captures:
          '1': {name: keyword.control.flow.python}
      - match: \b(lambda)\s*?(?=[,\n]|$)
        captures:
          '1': {name: storage.type.function.lambda.python}
      - name: meta.lambda-function.python
        begin: |
          (?x)
            \b (lambda) \b
        end: (:)|(\n)
        beginCaptures:
          '1': {name: storage.type.function.lambda.python}
        endCaptures:
          '1': {name: punctuation.section.function.lambda.begin.python}

        contentName: meta.function.lambda.parameters.python
        patterns:
          - name: keyword.operator.unpacking.parameter.python
            match: (\*\*|\*)
          - include: '#lambda-nested-incomplete'
          - include: '#illegal-names'
          - match: ([[:alpha:]_]\w*)\s*(?:(,)|(?=:|$))
            captures:
              '1': {name: variable.parameter.function.language.python}
              '2': {name: punctuation.separator.parameters.python}

          - include: '#comments'
          - include: '#backticks'
          - include: '#illegal-anno'
          - include: '#lambda-parameter-with-default'
          - include: '#line-continuation'
          - include: '#illegal-operator'

  lambda-incomplete:
    name: storage.type.function.lambda.python
    match: \blambda(?=\s*[,)])

  lambda-nested-incomplete:
    name: storage.type.function.lambda.python
    match: \blambda(?=\s*[:,)])

  lambda-parameter-with-default:
    begin: |
      (?x)
        \b
        ([[:alpha:]_]\w*) \s* (=)
    end: (,)|(?=:|$)
    beginCaptures:
      '1': {name: variable.parameter.function.language.python}
      '2': {name: keyword.operator.python}
    endCaptures:
      '1': {name: punctuation.separator.parameters.python}
    patterns:
      - include: '#expression'

  function-declaration:
    name: meta.function.python
    begin: |
      (?x)
        \s*
        (?:\b(async) \s+)? \b(def)\s+
          (?=
            [[:alpha:]_][[:word:]]* \s* \(
          )

    end: (:|(?=[#'"\n]))
    beginCaptures:
      '1': {name: storage.type.function.async.python}
      '2': {name: storage.type.function.python}

    endCaptures:
      '1': {name: punctuation.section.function.begin.python}

    patterns:
      - include: '#function-def-name'
      - include: '#parameters'
      - include: '#line-continuation'
      - include: '#return-annotation'

  scenario-declaration:
    comment: Also handles behavior declarations.
    name: meta.function.python
    begin: |
      (?x)
        ^\s*
        \b(scenario | behavior)\s+
          (?=
            [[:alpha:]_][[:word:]]* \s* \(
          )

    end: (:|(?=[#'"\n]))
    beginCaptures:
      '1': {name: storage.type.function.python}

    endCaptures:
      '1': {name: punctuation.section.function.begin.python}

    patterns:
      - include: '#function-def-name'
      - include: '#parameters'
      - include: '#line-continuation'
      - include: '#return-annotation'

  monitor-declaration:
    name: meta.function.python
    begin: |
      (?x)
        ^\s*
        \b(monitor)\s+
          (?=
            [[:alpha:]_][[:word:]]* \s* :
          )
    end: (:)
    beginCaptures:
      '1': {name: storage.type.function.python}
    endCaptures:
      '1': {name: punctuation.section.function.begin.python}
    patterns:
      - include: '#function-def-name'

  function-def-name:
    patterns:
      - include: '#illegal-object-name'
      - include: '#builtin-possible-callables'
      - name: entity.name.function.python
        match: |
          (?x)
            \b ([[:alpha:]_]\w*) \b

  parameters:
    name: meta.function.parameters.python
    begin: (\()
    end: (\))
    beginCaptures:
      '1': {name: punctuation.definition.parameters.begin.python}
    endCaptures:
      '1': {name: punctuation.definition.parameters.end.python}

    patterns:
      - name: keyword.operator.unpacking.parameter.python
        match: (\*\*|\*)
      - include: '#lambda-incomplete'
      - include: '#illegal-names'
      - include: '#illegal-object-name'
      - include: '#parameter-special'
      - match: |
          (?x)
            ([[:alpha:]_]\w*)
              \s* (?: (,) | (?=[)#\n=]))
        captures:
          '1': {name: variable.parameter.function.language.python}
          '2': {name: punctuation.separator.parameters.python}

      - include: '#comments'
      - include: '#loose-default'
      - include: '#annotated-parameter'

  parameter-special:
    match: |
      (?x)
        \b ((self)|(cls)) \b \s*(?:(,)|(?=\)))
    captures:
      '1': {name: variable.parameter.function.language.python}
      '2': {name: variable.parameter.function.language.special.self.python}
      '3': {name: variable.parameter.function.language.special.cls.python}
      '4': {name: punctuation.separator.parameters.python}

  loose-default:
    begin: (=)
    end: (,)|(?=\))
    beginCaptures:
      '1': {name: keyword.operator.python}
    endCaptures:
      '1': {name: punctuation.separator.parameters.python}
    patterns:
      - include: '#expression'

  annotated-parameter:
    begin: |
      (?x)
        \b
        ([[:alpha:]_]\w*) \s* (:)
    end: (,)|(?=\))
    beginCaptures:
      '1': {name: variable.parameter.function.language.python}
      '2': {name: punctuation.separator.annotation.python}
    endCaptures:
      '1': {name: punctuation.separator.parameters.python}
    patterns:
      - include: '#expression'
      - name: keyword.operator.assignment.python
        match: =(?!=)

  return-annotation:
    begin: (->)
    end: (?=:)
    beginCaptures:
      '1': {name: punctuation.separator.annotation.result.python}
    patterns:
      - include: '#expression'

  item-access:
    patterns:
      - name: meta.item-access.python
        begin: |
          (?x)
            \b(?=
              [[:alpha:]_]\w* \s* \[
            )
        end: (\])
        endCaptures:
          '1': {name: punctuation.definition.arguments.end.python}
        patterns:
          - include: '#item-name'
          - include: '#item-index'
          - include: '#expression'

  item-name:
    patterns:
      - include: '#special-variables'
      - include: '#builtin-functions'
      - include: '#special-names'
      - match: |
          (?x)
            \b ([[:alpha:]_]\w*) \b

  item-index:
    begin: (\[)
    end: (?=\])
    beginCaptures:
      '1': {name: punctuation.definition.arguments.begin.python}
    contentName: meta.item-access.arguments.python
    patterns:
      - name: punctuation.separator.slice.python
        match: ":"
      - include: '#expression'

  decorator:
    name: meta.function.decorator.python
    begin: |
      (?x)
        ^\s*
        ((@)) \s* (?=[[:alpha:]_]\w*)
    end: |
        (?x)
          ( \) )
            # trailing whitespace and comments are legal
            (?: (.*?) (?=\s*(?:\#|$)) )
          | (?=\n|\#)
    beginCaptures:
      '1': {name: entity.name.function.decorator.python}
      '2': {name: punctuation.definition.decorator.python}
    endCaptures:
      '1': {name: punctuation.definition.arguments.end.python}
      '2': {name: invalid.illegal.decorator.python}

    patterns:
      - include: '#decorator-name'
      - include: '#function-arguments'

  decorator-name:
    patterns:
      - include: '#builtin-callables'
      - include: '#illegal-object-name'
      - name: entity.name.function.decorator.python
        match: |
          (?x)
            ([[:alpha:]_]\w*) | (\.)
        captures:
          '2': {name: punctuation.separator.period.python}
      - include: '#line-continuation'
      - name: invalid.illegal.decorator.python
        match: |
          (?x)
            \s* ([^([:alpha:]\s_\.#\\] .*?) (?=\#|$)
        captures:
          '1': {name: invalid.illegal.decorator.python}

  call-wrapper-inheritance:
    comment: same as a function call, but in inheritance context
    name: meta.function-call.python
    begin: |
      (?x)
        \b(?=
          ([[:alpha:]_]\w*) \s* (\()
        )
    end: (\))
    endCaptures:
      '1': {name: punctuation.definition.arguments.end.python}
    patterns:
      - include: '#inheritance-name'
      - include: '#function-arguments'

  inheritance-name:
    patterns:
      - include: '#lambda-incomplete'
      - include: '#builtin-possible-callables'
      - include: '#inheritance-identifier'

  function-call:
    name: meta.function-call.python
    begin: |
      (?x)
        \b(?=
          ([[:alpha:]_]\w*) \s* (\()
        )
    end: (\))
    endCaptures:
      '1': {name: punctuation.definition.arguments.end.python}
    patterns:
      - include: '#special-variables'
      - include: '#function-name'
      - include: '#function-arguments'

  function-name:
    patterns:
      - include: '#builtin-possible-callables'
      - comment: Some color schemas support meta.function-call.generic scope
        name: meta.function-call.generic.python variable.function.scenic
        match: |
          (?x)
            \b ([[:alpha:]_]\w*) \b

  function-arguments:
    begin: (\()
    end: (?=\))(?!\)\s*\()
    beginCaptures:
      '1': {name: punctuation.definition.arguments.begin.python}
    contentName: meta.function-call.arguments.python
    patterns:
      - name: punctuation.separator.arguments.python
        match: (,)
      - match: |
          (?x)
            (?:(?<=[,(])|^) \s* (\*{1,2})
        captures:
          '1': {name: keyword.operator.unpacking.arguments.python}
      - include: '#lambda-incomplete'
      - include: '#illegal-names'
      - match: '\b([[:alpha:]_]\w*)\s*(=)(?!=)'
        captures:
          '1': {name: variable.parameter.function-call.python}
          '2': {name: keyword.operator.assignment.python}

      - name: keyword.operator.assignment.python
        match: =(?!=)
      - include: '#expression'
      - match: \s*(\))\s*(\()
        captures:
          '1': {name: punctuation.definition.arguments.end.python}
          '2': {name: punctuation.definition.arguments.begin.python}

  builtin-callables:
    patterns:
      - include: '#illegal-names'
      - include: '#illegal-object-name'
      - include: '#builtin-exceptions'
      - include: '#builtin-functions'
      - include: '#builtin-types'
      - include: '#builtin-types-scenic'

  builtin-possible-callables:
    patterns:
      - include: '#builtin-callables'
      - include: '#magic-names'

  builtin-exceptions:
    name: support.type.exception.python
    match: |
      (?x) (?<!\.) \b(
        (
          Arithmetic | Assertion | Attribute | Buffer | BlockingIO
          | BrokenPipe | ChildProcess
          | (Connection (Aborted | Refused | Reset)?)
          | EOF | Environment | FileExists | FileNotFound
          | FloatingPoint | IO | Import | Indentation | Index | Interrupted
          | IsADirectory | NotADirectory | Permission | ProcessLookup
          | Timeout
          | Key | Lookup | Memory | Name | NotImplemented | OS | Overflow
          | Reference | Runtime | Recursion | Syntax | System
          | Tab | Type | UnboundLocal | Unicode(Encode|Decode|Translate)?
          | Value | Windows | ZeroDivision | ModuleNotFound
        ) Error
      |
        ((Pending)?Deprecation | Runtime | Syntax | User | Future | Import
          | Unicode | Bytes | Resource
        )? Warning
      |
        SystemExit | Stop(Async)?Iteration
        | KeyboardInterrupt
        | GeneratorExit | (Base)?Exception
        | (Guard | Precondition | Invariant)Violation
      )\b

  builtin-functions:
    patterns:
      - name: support.function.builtin.python
        match: |
          (?x)
            (?<!\.) \b(
              __import__ | abs | all | any | ascii | bin | breakpoint | callable
              | chr | compile | copyright | credits | delattr | dir | divmod
              | enumerate | eval | exec | exit | filter | format | getattr
              | globals | hasattr | hash | help | hex | id | input
              | isinstance | issubclass | iter | len | license | locals | map
              | max | memoryview | min | next | oct | open | ord | pow | print
              | quit | range | reload | repr | reversed | round
              | setattr | sorted | sum | vars | zip
            )\b

      - name: support.function.builtin.scenic
        match: |
          (?x)
            (?<!\.) \b(
              resample | localPath | verbosePrint | simulation
              | sin | cos | hypot
            )\b

      - name: variable.legacy.builtin.python
        match: |
          (?x)
            (?<!\.) \b(
              file | reduce | intern | raw_input | unicode | cmp | basestring
              | execfile | long | xrange
            )\b

  builtin-types:
    name: support.type.python
    match: |
      (?x)
        (?<!\.) \b(
          bool | bytearray | bytes | classmethod | complex | dict
          | float | frozenset | int | list | object | property
          | set | slice | staticmethod | str | tuple | type

          (?# Although 'super' is not a type, it's related to types,
              and is special enough to be highlighted differently from
              other built-ins)
          | super
        )\b

  builtin-types-scenic:
    name: support.type.scenic
    match: |
      (?x)
        (?<!\.) \b(
          Point | OrientedPoint | Object
          | Vector | VectorField | PolygonalVectorField
          | Region | PointSetRegion | RectangularRegion | CircularRegion
          | SectorRegion | PolygonalRegion | PolylineRegion
          | Workspace
          | Range | DiscreteRange | Options | Discrete | Uniform
          | Normal | TruncatedNormal
          | VerifaiParameter | VerifaiRange | VerifaiDiscreteRange | VerifaiOptions
        )\b

  builtin-names-scenic:
    name: support.constant.scenic
    match: |
      (?x)
        (?<!\.) \b(
          globalParameters
        )\b

  magic-function-names:
    comment: |
      these methods have magic interpretation by python and are generally called
      indirectly through syntactic constructs
    match: |
      (?x)
        \b(
          __(?:
            abs | add | aenter | aexit | aiter | and | anext | await
            | bool | call | ceil | cmp | coerce | complex | contains
            | copy | deepcopy | del | delattr | delete | delitem
            | delslice | dir | div | divmod | enter | eq | exit | float
            | floor | floordiv | format | ge | get | getattr
            | getattribute | getinitargs | getitem | getnewargs
            | getslice | getstate | gt | hash | hex | iadd | iand | idiv
            | ifloordiv | ilshift | imod | imul | index | init
            | instancecheck | int | invert | ior | ipow | irshift | isub
            | iter | itruediv | ixor | le | len | long | lshift | lt
            | missing | mod | mul | ne | neg | new | next | nonzero | oct | or
            | pos | pow | radd | rand | rdiv | rdivmod | reduce
            | reduce_ex | repr | reversed | rfloordiv | rlshift | rmod
            | rmul | ror | round | rpow | rrshift | rshift | rsub
            | rtruediv | rxor | set | setattr | setitem | setslice
            | setstate | sizeof | str | sub | subclasscheck | truediv
            | trunc | unicode | xor | matmul | rmatmul | imatmul
            | init_subclass | set_name | fspath | bytes | prepare
          )__
        )\b
    captures:
      '1': {name: support.function.magic.python}

  magic-variable-names:
    comment: magic variables which a class/module may have.
    match: |
      (?x)
        \b(
          __(?:
            all | bases | builtins | class | class_getitem | code | debug
            | defaults | dict | doc | file | func | kwdefaults | members
            | metaclass | methods | module | mro | mro_entries | name
            | qualname | post_init | self | signature | slots | subclasses
            | version | weakref | wrapped | annotations | classcell
            | spec | path | package | future | traceback
          )__
        )\b
    captures:
      '1': {name: support.variable.magic.python}

  magic-names:
    patterns:
      - include: '#magic-function-names'
      - include: '#magic-variable-names'

  illegal-names:
    match: |
      (?x)
        \b(?:
          (
            and | as | assert | async | await | break | class | continue | def
            | del | elif | else | except | finally | for | from | global
            | if | in | is | (?<=\.)lambda | lambda(?=\s*[\.=])
            | nonlocal | not | or | pass | raise | return | try | while | with
            | yield
          ) | (
            import
          )
        )\b
    captures:
      '1': {name: keyword.control.flow.python}
      '2': {name: keyword.control.import.python}


  special-variables:
    match: |
      (?x)
        \b (?<!\.) (?:
          (self) | (cls) | (ego) | (workspace)
        )\b
    captures:
      '1': {name: variable.language.special.self.python}
      '2': {name: variable.language.special.cls.python}
      '3': {name: variable.language.special.ego.scenic}
      '4': {name: variable.language.special.workspace.scenic}

  ellipsis:
    name: constant.other.ellipsis.python
    match: \.\.\.

  backticks:
    name: invalid.deprecated.backtick.python
    begin: \`
    end: (?:\`|(?<!\\)(\n))
    patterns:
      - include: '#expression'

  illegal-operator:
    patterns:
      - name: invalid.illegal.operator.python
        match: '&&|\|\||--|\+\+'
      - name: invalid.illegal.operator.python
        match: '[?$]'
      - name: invalid.illegal.operator.python
        comment: We don't want `!` to flash when we're typing `!=`
        match: '!\b'

  illegal-object-name:
    comment: It's illegal to name class or function "True"
    name: keyword.illegal.name.python
    match: \b(True|False|None)\b

  illegal-anno:
    name: invalid.illegal.annotation.python
    match: '->'
...
