""" A contract describing an automatic cruise control system"""

import math
import random
from typing import Union
import numpy

from scenic.core.geometry import normalizeAngle
from scenic.domains.driving.controllers import PIDLongitudinalController, PIDLateralController
from scenic.domains.driving.actions import RegulatedControlAction

# ## World File ##
ENVIRONMENT = scenarioFromFile(localPath("highway.scenic"), mode2D=True)

SEED=5
random.seed(SEED)
numpy.random.seed(SEED)

## Components ##

# Dummy Sensors components
component NoisyDistanceSystem(stddev, init_seed=1, overestimate=False):
    """ A component that provides noisy distance to the car in front."""
    sensors:
        self.leadDist: float as sensors_distance

    outputs:
        dist: float

    state:
        seed: int = init_seed

    body:
        noise = random.gauss(sigma=stddev)
        if overestimate:
            noise = abs(noise)
        noisy_distance = sensors_distance + noise
        state.seed = random.randint(1,1000000)
        return {"dist": noisy_distance}

component Speedometer():
    """ Fetches and outputss ground truth speed."""
    sensors:
        self.speed: float as speed_val

    outputs:
        speed: float

    body:
        return {"speed": speed_val}

component DirectionSystem():
    """ A component that provides ground truth directional information."""
    sensors:
        self.targetDir: float as sensors_direction
        self.heading: float as sensors_heading

    outputs:
        direction: float
        heading: float

    body:
        return {"direction": sensors_direction, "heading": sensors_heading}

# Controller Signal Systems
component PIDThrottleSystem(target_dist, max_speed):
    """ A simple PID controller that attempts to maintain a set distance
    from the car in front of it while regulating its speed.
    """
    inputs:
        dist: float
        speed: float

    outputs:
        throttle: float

    state:
        # This is for speed, so maybe we need a specific one for distance?
        # Not sure what assumptions are made.
        pid_controller: PIDLongitudinalController = PIDLongitudinalController(K_D=0.1, K_I=0)

    body:
        throttle = state.pid_controller.run_step(dist-target_dist)

        # Basic speed limiter, don't accelerate if we're already going too fast.
        if speed >= max_speed:
            throttle = min(0, throttle)

        return {"throttle": float(throttle)}

component ThrottleSafetyFilter(min_dist, min_slowdown, max_brake=5, buffer_padding=0):
    """ A component that modulates actions, passing them through unchanged
    unless we are dangerously close to the car in front of us, in which case
    the actions are swapped to brake with maximum force.
    """
    sensors:
        self.timestep: float as timestep

    inputs:
        dist: float
        speed: float
        throttle: float

    outputs:
        modulated_throttle: float

    state:
        last_dist: Union[None, float] = None

    body:
        # In first timestep, don't take any action
        if state.last_dist is None:
            state.last_dist = dist
            return {"modulated_throttle": 0.0}

        # If we are in the "danger zone", brake HARD. Otherwise, pass through the inputs actions action.
        rel_speed = (state.last_dist - dist)/timestep
        stopping_time = math.ceil(rel_speed/min_slowdown)+1
        rel_dist_covered = stopping_time*speed + (max_brake - min_slowdown)*(stopping_time*(stopping_time+1))/2
        danger_dist = min_dist + buffer_padding + max(0, rel_dist_covered)

        # Update last_dist
        state.last_dist = dist

        if dist < danger_dist:
            return {"modulated_throttle": -1.0}
        else:
            return {"modulated_throttle": float(throttle)}

component PIDSteeringSystem():
    inputs:
        direction: float
        heading: float

    outputs:
        steer: float

    state:
        # This is for speed, so maybe we need a specific one for distance?
        # Not sure what assumptions are made.
        pid_controller: PIDLateralController = PIDLateralController()

    body:
        direction_err = normalizeAngle(normalizeAngle(heading) - normalizeAngle(direction))
        steer = state.pid_controller.run_step(direction_err)

        return {"steer": steer}

# Controller Boilerplate

component ActionGenerator():
    """ Given a throttle and steer signal, outputs a RegulatedControlAction."""
    inputs:
        throttle: float
        steer: float

    outputs:
        control_action: RegulatedControlAction

    state:
        past_steer: float = 0.0

    body:
        action = RegulatedControlAction(throttle, steer, state.past_steer,
            max_throttle=1, max_brake=1, max_steer=1)
        state.past_steer = steer
        return {"control_action": action}


component ControlSystem(target_dist, max_speed, min_dist, min_slowdown):
    """ The control system for a car, combining a PID controller with a
    safety filter to generate actions.
    """
    inputs:
        dist: float
        speed: float
        direction: float
        heading: float

    outputs:
        foo: float
        control_action: RegulatedControlAction

    compose:
        # Create sub-components
        pid_ts = PIDThrottleSystem(target_dist, max_speed)
        tsf = ThrottleSafetyFilter(min_dist, min_slowdown)
        pid_ss = PIDSteeringSystem()
        ag = ActionGenerator()

        # DEBUG
        connect dist to foo

        # Connect sensors inputss
        connect dist to pid_ts.dist
        connect speed to pid_ts.speed
        connect dist to tsf.dist
        connect speed to tsf.speed
        connect direction to pid_ss.direction
        connect heading to pid_ss.heading

        # Connect pid throttle to filter
        connect pid_ts.throttle to tsf.throttle

        # Connect control signals to action generator
        connect tsf.modulated_throttle to ag.throttle
        connect pid_ss.steer to ag.steer

        # outputs the generated action
        connect ag.control_action to control_action

component CarControls():
    """ This component receives actions for the car and executes them
    Convention is that any non-None action passed into an action component
    is taken each turn.
    """
    actions:
        control_action: RegulatedControlAction

component Car(stddev, target_dist, max_speed, min_dist, min_slowdown):
    compose:
        ps = NoisyDistanceSystem(stddev)
        sm = Speedometer()
        ds = DirectionSystem()
        cs = ControlSystem(target_dist, max_speed, min_dist, min_slowdown)
        cc = CarControls()

        # Connect sensors inputss to controller
        connect ps.dist to cs.dist
        connect sm.speed to cs.speed
        connect ds.direction to cs.direction
        connect ds.heading to cs.heading

        # Connect controller actions to car controls
        connect cs.control_action to cc.control_action

## Contracts ##
contract AccurateDistance(perception_distance, abs_dist_err=0.5):
    """ Contract proving that perceived distance is relatively accurate."""
    globals:
        objects
        workspace

    outputs:
        dist: float

    definitions:
        cars = [obj for obj in objects if hasattr(obj, "isVehicle") and obj.isVehicle and obj.position is not self.position]
        lead_distances = {car: leadDistance(self, car, workspace.network, maxDistance=2*perception_distance) for car in cars}
        lead_car = sorted(cars, key=lambda x: lead_distances[x])[0]
        lead_dist = lead_distances[lead_car]
        behind_car = lead_dist <= perception_distance

    assumptions:
        # Assume we are in a lane
        always self._lane is not None

    guarantees:
        # Guarantee that if we're behind a car (in visible range), that the reported distance
        # is relatively accurate.
        always (behind_car implies (lead_dist-abs_dist_err <= dist <= lead_dist+abs_dist_err))
        # Guarantee that if we are not behind a car (or out of visible range), that any reported
        # distance is greater than our visible range.
        always ((not behind_car) implies (dist > perception_distance+abs_dist_err))

contract AccurateRelativeSpeeds(perception_distance, abs_dist_err=0.5, abs_speed_err=0.5, max_brake=float("inf"), max_accel=float("inf")):
    """ Contract proving that if we have access to relatively accurate distance, 
    we can get a relatively accurate relative speed between the two cars (Assuming
    max braking/acceleration forces).
    """
    globals:
        objects
        workspace

    outputs:
        dist: float

    definitions:
        cars = [obj for obj in objects if hasattr(obj, "isVehicle") and obj.isVehicle and obj.position is not self.position]
        lead_distances = {car: leadDistance(self, car, workspace.network, maxDistance=2*perception_distance) for car in cars}
        lead_car = sorted(cars, key=lambda x: lead_distances[x])[0]
        lead_dist = lead_distances[lead_car]
        behind_car = lead_dist <= perception_distance

        # Lead speed can be roughly calculated by comparing two timesteps
        relative_speed = ((next dist) - dist)/self.timestep
        true_relative_speed =  lead_car.speed - self.speed

    assumptions:
        # Assume we are in a lane and have relatively accurate distance
        always self._lane is not None

        always (behind_car implies (lead_dist-abs_dist_err <= dist <= lead_dist+abs_dist_err))

        # Assume that the lead car is not going to brake or accelerate with too much force.
        always (-max_brake <= (next lead_car.speed) - lead_car.speed <= max_accel)

    guarantees:
        # Guarantee that the perceived speed of the lead car is relatively accurate
        always (behind_car implies (relative_speed-abs_speed_err <= true_relative_speed <= relative_speed+abs_speed_err))

contract SafeThrottleFilter(perception_distance, min_dist, abs_dist_err=0.5, abs_speed_err=0.5, max_brake=float("inf")):
    """ A contract stating that if inputs indicate we are too close for safety, we issue a braking action."""
    inputs:
        dist: float
        speed: float
        throttle: float

    outputs:
        modulated_throttle: float

    definitions:
        # Lead speed can be roughly calculated by comparing two timesteps
        relative_speed = ((next dist) - dist)/self.timestep if (next(next dist)) else ((next dist) - dist)/self.timestep
        true_relative_speed =  lead_car.speed - speed

        stopping_time = math.ceil(speed/max_brake)
        rel_dist_covered = stopping_time*speed + (true_relative_speed+abs_speed_err)(max_brake-min_slowdown)*(stopping_time*(stopping_time+1))/2
        buffer_dist = min_dist + rel_dist_covered

    guarantees:
        # Guarantee that if we sense we are too close to the car in front of us, we brake with max force.
        always (dist < buffer_dist+abs_dist_error) implies (modulated_throttle == -1)

contract PassthroughBrakingActionGenerator():
    """ A contract stating that the outputted action represents the input throttle"""
    inputs:
        throttle: float

    outputs:
        control_action: RegulatedControlAction

    definitions:
        accelerating = throttle >= 0
        braking = throttle < 0

    guarantees:
        always throttle == -1 implies (control_action.throttle == 0 and control_action.brake == 1)

contract MaxBrakingForce(min_slowdown):
    actions:
        control_action: RegulatedControlAction

    definitions:
        no_throttle = control_action.throttle == 0
        full_brake = control_action.brake == 1

    guarantees:
        always ((no_throttle and full_brake)
            implies (self.speed == 0 or ((next self.speed) == self.speed - max_brake))
        )

## Overall System Spec ##
contract KeepsDistance(perception_distance, min_dist, max_brake=float("inf"), max_accel=float("inf")):
    """ A contract stating we stay a safe distance from the car in front of us."""
    globals:
        objects
        workspace

    definitions:
        cars = [obj for obj in objects if hasattr(obj, "isVehicle") and obj.isVehicle and obj.position is not self.position]
        lead_distances = {car: leadDistance(self, car, workspace.network, maxDistance=2*perception_distance) for car in cars}
        lead_car = sorted(cars, key=lambda x: lead_distances[x])[0]
        lead_dist = lead_distances[lead_car]
        behind_car = lead_dist <= perception_distance

        true_relative_speed = lead_car.speed - self.speed

        stopping_time = math.ceil(self.speed/max_brake)
        rel_dist_covered = stopping_time*self.speed + (true_relative_speed + abs_speed_err)
        delta_stopping_time = math.ceil((self.speed+max_accel)/max_brake)
        max_rdc_delta = delta_stopping_time*self.speed + (true_relative_speed + max_brake + max_accel + abs_speed_err)
        buffer_dist = min_dist + (max(0, max_rdc_delta + rel_dist_covered))

    assumptions:
        # Assume we are in a lane
        always self._lane is not None

        # Assume lower and upper bounds on our speed.
        always 0 <= self.speed <= max_speed

        # Assume lower and upper bounds on the lead car's speed.
        always 0 <= lead_car.speed <= max_speed

        # Assume that the we are not going to brake or accelerate with too much force.
        always -max_brake <= (next self.speed) - self.speed <= max_accel

        # Assume that the lead car is not going to brake or accelerate with too much force.
        always -max_brake <= (next lead_car.speed) - lead_car.speed <= max_accel

        # Assume we start stopped outside the danger zone
        (lead_dist > buffer_dist) and (self.speed == 0)

        # Assume no one cuts in front us too closely
        always ((next lead_dist) == (lead_dist - true_relative_speed))

    guarantees:
        # Guarantee that we always stay at least min_dist behind the lead car
        always behind_car implies (lead_dist > min_dist)

## Verification Steps ##
# Constants
STDDEV = 0.1
TARGET_DIST = 10
MAX_SPEED = 26.8224 # 60 mph in m/s
MIN_DIST = 5
MIN_SLOWDOWN = 4.57 # 15 feet per second in m/s
MAX_BRAKE = 5 # TODO: Find reasonable value
MAX_ACCEL = 5 # TODO: Find reasonable value
PERCEPTION_DISTANCE = 250

ABS_DIST_ERR = 0.5
ABS_SPEED_ERR = 4

# Instantiate Car component and link to object.
implement "EgoCar" with Car(STDDEV, TARGET_DIST, MAX_SPEED, MIN_DIST, MIN_SLOWDOWN) as car

accurate_distance = test car.ps satisfies AccurateDistance(
    PERCEPTION_DISTANCE,
    abs_dist_err=ABS_DIST_ERR),
    using SimulationTesting(scenario=ENVIRONMENT, maxSteps=6, confidence=0.95, batchSize=10, verbose=False),
    terminating after 100 samples

# TODO: Replace with proof
accurate_speed = assume car.ps satisfies AccurateRelativeSpeeds(
        PERCEPTION_DISTANCE,
        abs_dist_err=ABS_DIST_ERR,
        abs_speed_err=ABS_SPEED_ERR,
        max_brake=MAX_BRAKE,
        max_accel=MAX_ACCEL)

ps_accuracy = compose over car.ps:
    use accurate_distance
    use accurate_speed

cs_safety = compose over car.cs:
    # TODO: Replace with proof
    assume car.cs.tsf satisfies SafeThrottleFilter(
            PERCEPTION_DISTANCE,
            MIN_DIST,
            MIN_SLOWDOWN,
            abs_speed_err=ABS_SPEED_ERR,
            max_brake=MAX_BRAKE)

    # TODO: Replace with proof
    assume car.cs.ag satisfies PassthroughBrakingActionGenerator()

max_braking_force = assume car.cc satisfies MaxBrakingForce(MIN_SLOWDOWN), with correctness 0.99, with confidence 0.99

keeps_distance_raw = compose over car:
    use ps_accuracy
    use cs_safety
    use max_braking_force

# keeps_distance = refine keeps_distance_raw as KeepsDistance(PERCEPTION_DISTANCE,
#     MIN_DIST,
#     abs_dist_err=ABS_DIST_ERR,
#     abs_speed_err=ABS_SPEED_ERR,
#     max_brake=MAX_BRAKE,
#     max_accel=MAX_ACCEL) using LeanProof("KeepsDistanceRefinement")

verify keeps_distance_raw
