""" A contract describing an automatic cruise control system"""

import math
import random
from typing import Union
import numpy

from scenic.core.geometry import normalizeAngle
from scenic.domains.driving.controllers import PIDLongitudinalController, PIDLateralController
from scenic.domains.driving.actions import RegulatedControlAction

# ## World File ##
ENVIRONMENT = scenarioFromFile(localPath("highway.scenic"), mode2D=True)

SEED=5
random.seed(SEED)
numpy.random.seed(SEED)

## Components ##

# Dummy Sensors components
component NoisyDistanceSystem(stddev, init_seed=1, overestimate=False):
    """ A component that provides noisy distance to the car in front."""
    sensors:
        self.leadDist: float as sensors_distance

    outputs:
        dist: float

    state:
        seed: int = init_seed

    body:
        noise = random.gauss(sigma=stddev)
        if overestimate:
            noise = abs(noise)
        noisy_distance = sensors_distance + noise
        state.seed = random.randint(1,1000000)
        return {"dist": noisy_distance}

component Speedometer():
    """ Fetches and outputss ground truth speed."""
    sensors:
        self.speed: float as speed_val

    outputs:
        speed: float

    body:
        return {"speed": speed_val}

component DirectionSystem():
    """ A component that provides ground truth directional information."""
    sensors:
        self.targetDir: float as sensors_direction
        self.heading: float as sensors_heading

    outputs:
        direction: float
        heading: float

    body:
        return {"direction": sensors_direction, "heading": sensors_heading}

# Controller Signal Systems
component PIDThrottleSystem(target_dist, max_speed):
    """ A simple PID controller that attempts to maintain a set distance
    from the car in front of it while regulating its speed.
    """
    inputs:
        dist: float
        speed: float

    outputs:
        throttle: float

    state:
        # This is for speed, so maybe we need a specific one for distance?
        # Not sure what assumptions are made.
        pid_controller: PIDLongitudinalController = PIDLongitudinalController(K_D=0.1, K_I=0)

    body:
        throttle = state.pid_controller.run_step(dist-target_dist)

        # Basic speed limiter, don't accelerate if we're already going too fast.
        if speed >= max_speed:
            throttle = min(0, throttle)

        return {"throttle": float(throttle)}

component ThrottleSafetyFilter(min_dist, abs_speed_err, max_accel, max_brake, max_speed, buffer_padding=1, timestep=0.1, perception_distance=1000):
    """ A component that modulates actions, passing them through unchanged
    unless we are dangerously close to the car in front of us, in which case
    the actions are swapped to brake with maximum force.
    """
    inputs:
        dist: float
        speed: float
        throttle: float

    outputs:
        modulated_throttle: float

    state:
        last_dist: float = 0.0

    body:
        # If we are in the "danger zone", brake HARD. Otherwise, pass through the inputs actions action.
        p_relative_speed = state.last_dist - dist
        p_stopping_time = ceil(speed/max_brake)
        p_rel_dist_covered = p_stopping_time * (p_relative_speed+abs_speed_err)
        p_delta_stopping_time = ceil((speed+max_accel)/max_brake)
        p_max_rdc_delta = p_delta_stopping_time * (p_relative_speed + max_brake + max_accel + 2*abs_speed_err) - p_rel_dist_covered 
        p_buffer_dist = min_dist + (max(0, p_max_rdc_delta + p_rel_dist_covered)) + max_speed + 1


        # Update last_dist
        state.last_dist = dist

        if dist < p_buffer_dist + buffer_padding:
            return {"modulated_throttle": -1.0}
        else:
            return {"modulated_throttle": throttle}

component PIDSteeringSystem():
    inputs:
        direction: float
        heading: float

    outputs:
        steer: float

    state:
        # This is for speed, so maybe we need a specific one for distance?
        # Not sure what assumptions are made.
        pid_controller: PIDLateralController = PIDLateralController()

    body:
        direction_err = normalizeAngle(normalizeAngle(heading) - normalizeAngle(direction))
        steer = state.pid_controller.run_step(direction_err)

        return {"steer": steer}

# Controller Boilerplate

component ControlSystem(target_dist, max_speed, min_dist, max_accel, max_brake, abs_speed_err):
    """ The control system for a car, combining a PID controller with a
    safety filter to generate control signals.
    """
    inputs:
        dist: float
        speed: float
        direction: float
        heading: float

    outputs:
        throttle: float
        steer: float

    compose:
        # Create sub-components
        pid_ts = PIDThrottleSystem(target_dist, max_speed)
        tsf = ThrottleSafetyFilter(min_dist, abs_speed_err, max_accel, max_brake, max_speed)
        pid_ss = PIDSteeringSystem()

        # Connect sensors inputs
        connect dist to pid_ts.dist
        connect speed to pid_ts.speed
        connect dist to tsf.dist
        connect speed to tsf.speed
        connect direction to pid_ss.direction
        connect heading to pid_ss.heading

        # Connect pid throttle to filter
        connect pid_ts.throttle to tsf.throttle

        # Connect control signals to outputs
        connect tsf.modulated_throttle to throttle
        connect pid_ss.steer to steer

component ActionGenerator():
    """ Given a throttle and steer signal, outputs a RegulatedControlAction."""
    inputs:
        throttle: float
        steer: float

    outputs:
        control_action: RegulatedControlAction

    state:
        past_steer: float = 0.0

    body:
        action = RegulatedControlAction(throttle, steer, state.past_steer,
            max_throttle=1, max_brake=1, max_steer=1)
        state.past_steer = steer
        return {"control_action": action}


component CarControls():
    """ This component receives actions for the car and executes them
    Convention is that any non-None action passed into an action component
    is taken each turn.
    """
    actions:
        control_action: RegulatedControlAction

component CarActionControls():
    """ This component takes control signals, converts them to actions, and takes the actions"""
    inputs:
        throttle: float
        steer: float

    compose:
        ag = ActionGenerator()
        cc = CarControls()        

        # Connect control signals to action generator
        connect throttle to ag.throttle
        connect steer to ag.steer

        # outputs the generated action
        connect ag.control_action to cc.control_action


component Car(stddev, target_dist, max_speed, min_dist, max_accel, max_brake, abs_speed_err):
    compose:
        ps = NoisyDistanceSystem(stddev)
        sm = Speedometer()
        ds = DirectionSystem()
        cs = ControlSystem(target_dist, max_speed, min_dist, max_accel, max_brake, abs_speed_err)
        cac = CarActionControls()

        # Connect sensors inputss to controller
        connect ps.dist to cs.dist
        connect sm.speed to cs.speed
        connect ds.direction to cs.direction
        connect ds.heading to cs.heading

        # Connect controller actions to car controls
        connect cs.throttle to cac.throttle
        connect cs.steer to cac.steer

## Contracts ##
contract AccurateDistance(perception_distance, abs_dist_err=0.5):
    """ Contract proving that perceived distance is relatively accurate."""
    globals:
        objects
        workspace

    outputs:
        dist: float

    definitions:
        cars = [obj for obj in objects if hasattr(obj, "isVehicle") and obj.isVehicle and obj.position is not self.position]
        lead_distances = {car: leadDistance(self, car, workspace.network, maxDistance=2*perception_distance) for car in cars}
        lead_car = sorted(cars, key=lambda x: lead_distances[x])[0]
        lead_dist = lead_distances[lead_car]
        behind_car = lead_dist <= perception_distance

    assumptions:
        # Assume we are in a lane
        always self._lane is not None

    guarantees:
        # Guarantee that if we're behind a car (in visible range), that the reported distance
        # is relatively accurate.
        always (behind_car implies (lead_dist-abs_dist_err <= dist <= lead_dist+abs_dist_err))
        # Guarantee that if we are not behind a car (or out of visible range), that any reported
        # distance is greater than our visible range.
        always ((not behind_car) implies (dist > perception_distance+abs_dist_err))

contract AccurateSpeed():
    outputs:
        speed: float

    guarantees:
        always speed == self.speed

contract SafeThrottleFilter(perception_distance, min_dist, max_speed, abs_dist_err=0.5, abs_speed_err=0.5, max_brake=float("inf"), max_accel=float("inf")):
    """ A contract stating that if inputs indicate we are too close for safety, we issue a braking action."""
    inputs:
        dist: float
        speed: float
        throttle: float

    outputs:
        modulated_throttle: float

    definitions:
        # Lead speed can be roughly calculated by comparing two timesteps
        p_relative_speed =  dist - (next dist)

        p_stopping_time = ceil((next speed)/max_brake)
        p_rel_dist_covered = p_stopping_time * (p_relative_speed+abs_speed_err)
        p_delta_stopping_time = ceil(((next speed)+max_accel)/max_brake)
        p_max_rdc_delta = p_delta_stopping_time * (p_relative_speed + max_brake + max_accel + 2*abs_speed_err) - p_rel_dist_covered 
        p_buffer_dist = min_dist + (max(0, p_max_rdc_delta + p_rel_dist_covered)) + max_speed + 1

    guarantees:
        # Guarantee that if we sense we are too close to the car in front of us, we brake with max force.
        always ((next dist) <= p_buffer_dist+abs_dist_err) implies ((next modulated_throttle) == -1)

contract MaxBrakingForce(max_brake):
    inputs:
        throttle: float
        steer: float

    guarantees:
        always ((throttle == -1)
            implies (((next self.speed) == 0) or ((next self.speed) == self.speed - max_brake))
        )

## Overall System Spec ##
contract KeepsDistance(perception_distance, min_dist, max_speed, abs_dist_err, abs_speed_err, max_brake=float("inf"), max_accel=float("inf")):
    """ A contract stating we stay a safe distance from the car in front of us."""
    globals:
        objects
        workspace

    definitions:
        cars = [obj for obj in objects if hasattr(obj, "isVehicle") and obj.isVehicle and obj.position is not self.position]
        lead_distances = {car: leadDistance(self, car, workspace.network, maxDistance=2*perception_distance) for car in cars}
        lead_car = sorted(cars, key=lambda x: lead_distances[x])[0]
        lead_dist = lead_distances[lead_car]
        behind_car = lead_dist <= perception_distance

        true_relative_speed = self.speed - lead_car.speed

        stopping_time = ceil(self.speed/max_brake)
        rel_dist_covered = stopping_time * (true_relative_speed+abs_speed_err)
        delta_stopping_time = ceil((self.speed+max_accel)/max_brake)
        max_rdc_delta = delta_stopping_time * (true_relative_speed + max_brake + max_accel + abs_speed_err) - rel_dist_covered 
        buffer_dist = min_dist + (max(0, max_rdc_delta + rel_dist_covered)) + max_speed + 1

    assumptions:
        # Assume we are in a lane
        always self._lane is not None

        # Assume lower and upper bounds on our speed.
        always 0 <= self.speed <= max_speed

        # Assume lower and upper bounds on the lead car's speed.
        always 0 <= lead_car.speed <= max_speed

        # Assume that the we are not going to brake or accelerate with too much force.
        always -max_brake <= (next self.speed) - self.speed <= max_accel

        # Assume that the lead car is not going to brake or accelerate with too much force.
        always -max_brake <= (next lead_car.speed) - lead_car.speed <= max_accel

        # Assume we start stopped outside the danger zone
        (lead_dist > buffer_dist) and (self.speed == 0)

        # Assume no one cuts in front us too closely
        always ((next lead_dist) == (lead_dist - true_relative_speed))

        always (self.timestep == 0.1)

    guarantees:
        # Guarantee that we always stay at least min_dist behind the lead car
        always lead_dist > min_dist

## Verification Steps ##
# Constants
STDDEV = 0.05
MIN_DIST = 5
MAX_BRAKE = 0.9
MAX_ACCEL = 0.5
PERCEPTION_DISTANCE = 1000
ABS_DIST_ERR = 0.1
ABS_SPEED_ERR = 1.6
MAX_SPEED = 5.4

TARGET_DIST = 10


# Instantiate Car component and link to object.
implement "EgoCar" with Car(STDDEV, TARGET_DIST, MAX_SPEED, MIN_DIST, MAX_ACCEL, MAX_BRAKE, ABS_SPEED_ERR) as car

accurate_distance = test car.ps satisfies AccurateDistance(
    PERCEPTION_DISTANCE,
    abs_dist_err=ABS_DIST_ERR),
    using SimulationTesting(scenario=ENVIRONMENT, maxSteps=6, confidence=0.95, batchSize=10, verbose=False),
    terminating after 100 samples

accurate_speed = assume car.sm satisfies AccurateSpeed()

cs_safety = compose over car.cs:
    prove car.cs.tsf satisfies SafeThrottleFilter(
            PERCEPTION_DISTANCE,
            MIN_DIST,
            MAX_SPEED,
            abs_dist_err=ABS_DIST_ERR,
            abs_speed_err=ABS_SPEED_ERR,
            max_brake=MAX_BRAKE,
            max_accel=MAX_ACCEL) using LeanContractProof(localPath("ScenicLean/"), "SafeThrottleFilter", localPath("repl"))

max_braking_force = assume car.cac satisfies MaxBrakingForce(MAX_BRAKE), with correctness 0.99, with confidence 0.99

keeps_distance_raw = compose over car:
    use accurate_distance
    use accurate_speed
    use cs_safety
    use max_braking_force

keeps_distance = refine keeps_distance_raw as KeepsDistance(PERCEPTION_DISTANCE,
    MIN_DIST,
    MAX_SPEED,
    ABS_DIST_ERR,
    ABS_SPEED_ERR,
    max_brake=MAX_BRAKE,
    max_accel=MAX_ACCEL) using LeanRefinementProof(localPath("ScenicLean/"), "KeepsDistanceRefinement", localPath("repl"))

verify keeps_distance
